col = "white"        # 'col = "white"' define el color del borde de las barras del histograma como blanco.
) +
# 'theme_bw()' aplica un tema en blanco y negro al gráfico.
# Este tema proporciona un contraste visual claro y es popular por su simplicidad y legibilidad.
theme_bw()
datos2 |> ggplot(aes(Quality.of.Sleep)) +
geom_histogram(
fill = "#9dcb43",
bins = 8,
col = "white"
) +
theme_bw()
knitr::opts_chunk$set(echo = TRUE,
eval = TRUE,
warning = FALSE,
message = FALSE,
error = TRUE)
library(tidyverse)
datos2 <- read.csv("Sleep_health_and_lifestyle_dataset.csv")
datos2|>count(Gender)
datos2 |>
ggplot(aes(x = Gender)) +
geom_bar(fill = "#9dcb43") +
theme_bw() +
labs(title = "Genero",
x = "Sexo",
y = "Frecuencia absoluta")
rango <- max(datos2$Age) - min(datos2$Age)
k <- round(rango / 5, 0)
limites <- seq(40, 40 + 5 * k, by = k)
limAge <- cut(datos2$Age, breaks = limites, right = TRUE)
datos2$Age <- cut(datos2$Age, breaks = c(0, 18, 25, 30, 35, 40, 45, 55, 60),
labels = c('0-17', '18-24.9', '25-29.9', '30-34.9', '35-39.9', '40-44.9', '45-54.9', '55-60'))
datos2 |> ggplot(aes(x = Age)) +
geom_bar(fill = "#9dcb43", col = "white") +
theme_bw()
datos2|>count(Occupation)
datos2 |>
ggplot(aes(x = Occupation)) +
geom_bar(fill = "#9dcb43") +
theme_bw() +
labs(title = "Genero",
x = "Profesion",
y = "Frecuencia absoluta")
#rango <- max(datos2$Sleep.Duration) - min(datos2$Sleep.Duration)
# Definir el número de intervalos para la duración del sueño
#j <- round(rango / 0.5, 0)
# Crear los límites para los intervalos de la duración del sueño
#limites <- seq(min(datos2$Sleep.Duration), max(datos2$Sleep.Duration), by = 0.5)
# Cortar los datos de la duración del sueño en intervalos definidos
#datos2$Sleep.Duration <- cut(datos2$Sleep.Duration, breaks = c(4, 4.5, 5, 5.5, 6, 6.5, 7, 7.5, 8, 8.5, 9),
#  labels = c('4-4.5', '4.5-5', '5-5.5', '5.5-6', '6-6.5', '6.5-7', '7-7.5', '7.5-8', '8-8.5', '8.5-9'))
# Gráfico de la duración del sueño
#datos2 |> ggplot(aes(x = Sleep.Duration)) +
#  geom_bar(fill = "#9dcb43", col = "white") +
# theme_bw() +
# labs(title = "Distribución de la Duración del Sueño",
#  x = "Horas de sueño",
# y = "Frecuencia")
datos2 |> ggplot(aes(Sleep.Duration)) +
geom_histogram(
fill = "#9dcb43",  # 'fill = "steelblue"' establece el color de relleno de las barras del histograma a azul acero.
bins = 15,           # 'bins = 15' especifica el número de barras (o "bins") que el histograma debe tener.
col = "white"        # 'col = "white"' define el color del borde de las barras del histograma como blanco.
) +
# 'theme_bw()' aplica un tema en blanco y negro al gráfico.
# Este tema proporciona un contraste visual claro y es popular por su simplicidad y legibilidad.
theme_bw()
datos2 |> ggplot(aes(Quality.of.Sleep)) +
geom_histogram(
fill = "#9dcb43",
bins = 8,
col = "white"
) +
theme_bw()
knitr::opts_chunk$set(echo = TRUE,
eval = TRUE,
warning = FALSE,
message = FALSE,
error = TRUE)
library(tidyverse)
library(summarytools)
library(GGally)
library(gt)
library(flextable)
library(knitr)
library(corrplot)
# 'download.file()' se usa para descargar un archivo desde internet.
# 'url = "http://emilio.lcano.com/data/eaci/lab.xlsx"' especifica la URL del archivo a descargar.
# Este es el enlace al archivo Excel que se quiere descargar.
download.file(url = "http://emilio.lcano.com/data/eaci/lab.xlsx",
# 'destfile = "lab.xlsx"' define el nombre del archivo en el que se guardará el archivo descargado.
# En este caso, el archivo se guardará como 'lab.xlsx' en el directorio de trabajo actual.
destfile = "lab.xlsx",
# 'mode = "wb"' se usa para especificar el modo de escritura del archivo.
# 'wb' significa escribir en modo binario, lo cual es importante para archivos no de texto como Excel.
mode = "wb")
# 'readxl::read_excel("lab.xlsx")' lee el archivo Excel 'lab.xlsx' que acabamos de descargar.
# 'readxl' es un paquete en R que proporciona funciones para leer archivos Excel.
lab <- readxl::read_excel("lab.xlsx") |>
# 'mutate(fecha = as.Date(fecha))' transforma la columna 'fecha' a formato de fecha.
# 'mutate()' es una función del paquete dplyr que se utiliza para añadir nuevas variables o transformar las existentes.
# 'as.Date()' convierte los datos a formato de fecha.
mutate(fecha = as.Date(fecha))
# 'lab |> slice_head(n=10)' selecciona las primeras 10 filas del dataframe 'lab'.
# 'lab' es el dataframe que se ha leído y preparado en los pasos anteriores.
# '|>' es el operador de tubería en R que permite pasar el resultado de una función a la siguiente.
lab |>
# 'slice_head(n=10)' es una función del paquete dplyr que selecciona las primeras 'n' filas del dataframe.
# En este caso, selecciona las primeras 10 filas.
slice_head(n=10) |>
# 'gt()' es una función del paquete gt que crea una tabla elegante y bien formateada.
# Convierte el resultado del dataframe reducido a una tabla que puede ser más fácilmente formateada y presentada.
gt()
# 'tabla_frecuencias <- lab |> count(tipo) |>' crea una tabla de frecuencias a partir del dataframe 'lab'.
tabla_frecuencias <- lab |>
# 'count(tipo)' cuenta el número de ocurrencias de cada valor único en la columna 'tipo'.
# Esta función agrupa por 'tipo' y luego cuenta las ocurrencias en cada grupo.
count(tipo) |>
# 'mutate()' añade nuevas columnas al dataframe.
# 'f = n/nrow(lab)' calcula la frecuencia relativa de cada 'tipo', dividiendo el conteo de cada tipo por el número total de filas en 'lab'.
mutate(f = n/nrow(lab),
# 'N = cumsum(n)' calcula la frecuencia acumulada (conteo acumulativo) para cada 'tipo'.
N = cumsum(n),
# 'F = cumsum(f)' calcula la frecuencia relativa acumulada.
F = cumsum(f))
# 'knitr::kable(tabla_frecuencias, digits = 4)' utiliza la función kable de knitr para crear una tabla bien formateada.
# 'digits = 4' especifica que los números se redondeen a 4 dígitos decimales.
knitr::kable(tabla_frecuencias, digits = 4)
# Calcula la tabla de frecuencias de la variable 'imperfecciones' en el dataframe 'lab'.
table(lab$imperfecciones) |>
# Convierte la tabla de frecuencias en un dataframe.
as.data.frame() |>
# Añade una nueva columna 'F' calculando la frecuencia relativa acumulada.
# Esto se logra sumando las frecuencias (Freq) acumulativamente y dividiéndolas por el número total de filas en 'lab'.
mutate(F = cumsum(Freq)/nrow(lab)) |>
# Convierte el dataframe resultante en una tabla 'gt' para formateo y estilización avanzados.
gt() |>
# Cambia las etiquetas de las columnas a notación matemática.
cols_label(Var1 = "\\(x_i\\)",  # Cambia el nombre de 'Var1' a 'x_i' (representando valores individuales).
Freq = "\\(n_i\\)",  # Cambia 'Freq' a 'n_i' (representando la frecuencia de cada valor).
F = "\\(F_i\\)") |>  # Cambia 'F' a 'F_i' (representando la frecuencia relativa acumulada de cada valor).
# Formatea los números a mostrar tres decimales.
fmt_number(3, decimals = 3) |>
# Aplica un estilo de texto en negrita a las filas específicas (3 y 5) en el cuerpo de la tabla.
tab_style(style = list(
cell_text(weight = "bold")),
locations = cells_body(rows = c(3, 5)))
# Inicia una visualización de ggplot con 'lab' como el dataframe y 'tipo' como variable en el eje x.
lab |>
ggplot(aes(x = tipo)) +
# Añade un gráfico de barras, rellenando las barras con el color #CB0017.
geom_bar(fill = "#CB0017") +
# Aplica un tema predeterminado en blanco y negro para la visualización.
theme_bw() +
# Establece los títulos del gráfico, eje x, y eje y.
labs(title = "Tipos de queso",
x = "Tipo",
y = "Frecuencia absoluta")
# 'fct_rev' invierte el orden de los factores para que el gráfico se muestre en orden inverso.
# 'as_factor' convierte la columna 'imperfecciones' en un factor si no lo es ya.
lab |>
mutate(imperfecciones = fct_rev(as_factor(imperfecciones))) |>
# Inicio de la creación del gráfico con ggplot2, especificando los datos y mapeando
# la variable 'imperfecciones' en el eje y.
ggplot(aes(y = imperfecciones)) +
# 'geom_bar' añade barras al gráfico. 'fill' especifica el color de relleno de las barras.
geom_bar(fill = "#CB0017") +
# Aplica un tema blanco y negro al gráfico para un diseño más limpio y profesional.
theme_bw() +
# Personaliza las etiquetas de los ejes y el título del gráfico. 'expression' permite
# usar expresiones matemáticas en las etiquetas.
labs(x = expression("Frecuencia absoluta ("*n[i]*")"),
y = "Número de imperfecciones")
# Inicia una visualización de ggplot con 'lab' como el dataframe, 'tipo' como variable en el eje x,
# y calcula la proporción (after_stat(prop)) para el eje y. Agrupación establecida para cálculos de proporción.
ggplot(lab, aes(x = tipo, y =  after_stat(prop), group = 1)) +
# Añade un gráfico de barras con conteo como estadística y rellena las barras basado en el conteo de 'tipo'.
geom_bar(aes(fill = after_stat(count)), stat = "count") +
# Escala el eje y para mostrar las etiquetas como porcentajes.
scale_y_continuous(labels = scales::percent) +  # Convierte las etiquetas de y en porcentajes
# Aplica un tema predeterminado en blanco y negro para la visualización.
theme_bw() +
# Establece los títulos del gráfico, eje x, y eje y.
labs(title = "Tipos de queso",
x = "Tipo",
y = "Frecuencia relativa") +
# Añade un degradado de color a las barras basado en la frecuencia de conteo, desde 'skyblue' a '#CB0017'.
scale_fill_gradient("Frecuencia", low = "skyblue", high = "#CB0017")  # Opcional: color de relleno basado en la frecuencia
# Primero, calcula las proporciones y conserva el conteo original
# 'lab' es el dataframe que contiene los datos.
# 'count(analista)' cuenta cuántas veces aparece cada 'analista'.
# 'mutate(prop = n / sum(n))' añade una nueva columna 'prop' que representa la proporción relativa.
analista_prop <- lab %>%
count(analista) %>%
mutate(prop = n / sum(n))
# Luego, usa ggplot para visualizar
# 'ggplot()' inicia la construcción de un gráfico.
# 'aes(x = reorder(analista, prop), y = prop, fill = n)' define las estéticas:
# 'x = reorder(analista, prop)' ordena los analistas en el eje x según su proporción.
# 'y = prop' asigna la proporción relativa al eje y.
# 'fill = n' usa el conteo original para el color de las barras.
ggplot(analista_prop, aes(x = reorder(analista, prop), y = prop, fill = n)) +
# 'geom_bar(stat = "identity")' crea un gráfico de barras.
# 'stat = "identity"' indica que ya se proporcionaron las alturas de las barras (proporciones).
geom_bar(stat = "identity") +
# 'scale_y_continuous(labels = scales::percent)' configura el eje y para mostrar las etiquetas como porcentajes.
scale_y_continuous(labels = scales::percent) +
# 'theme_bw()' aplica un tema visual en blanco y negro al gráfico.
theme_bw() +
# 'labs()' establece los títulos y etiquetas del gráfico.
# 'title', 'x', 'y' definen el título del gráfico y los títulos de los ejes x e y respectivamente.
labs(title = "Tipos de analista", x = "Tipo", y = "Frecuencia relativa") +
# 'scale_fill_gradient()' define un degradado de color para las barras.
# 'low' y 'high' especifican los colores para los valores bajos y altos del conteo respectivamente.
scale_fill_gradient("Frecuencia", low = "skyblue", high = "#CB0017")
# 'lab |> ggplot(aes(ph)) +' inicia la construcción de un gráfico utilizando ggplot2 con datos del dataframe 'lab'.
lab |> ggplot(aes(ph)) +
# 'aes(ph)' establece la estética del gráfico, asignando la variable 'ph' del dataframe 'lab' al eje x.
# 'geom_histogram()' añade un histograma al gráfico. Un histograma es útil para visualizar la distribución de una variable continua.
geom_histogram(
fill = "steelblue",  # 'fill = "steelblue"' establece el color de relleno de las barras del histograma a azul acero.
bins = 15,           # 'bins = 15' especifica el número de barras (o "bins") que el histograma debe tener.
col = "white"        # 'col = "white"' define el color del borde de las barras del histograma como blanco.
) +
# 'theme_bw()' aplica un tema en blanco y negro al gráfico.
# Este tema proporciona un contraste visual claro y es popular por su simplicidad y legibilidad.
theme_bw()
hist(lab$ph,
col = "#CB0017",
# 'main' define el título principal del gráfico.
main = "Histograma pH",
# 'bins' establece el número de barras a mostrar en el gráfico
bins = 15,
# 'xlab' y 'ylab' definen los títulos de los ejes X e Y, respectivamente.
xlab = "pH",
ylab = "Frecuencia",
# 'border' establece el color del borde de las barras del histograma a blanco.
border = "white")
# 'lab |> ggplot(aes(x= "ph", y = ph)) +' inicia una visualización ggplot2 usando el dataframe 'lab'.
lab |>
ggplot(aes(x= "ph", y = ph)) +  # Configura las estéticas del gráfico.
# 'aes()' define cómo se asignarán variables a estéticas visuales en el gráfico.
# 'x= "ph"' establece una constante para el eje x.
# 'y = ph' asigna la columna 'ph' del dataframe 'lab' al eje y.
# 'geom_boxplot()' añade un gráfico de cajas al gráfico.
# Esta función crea un diagrama de cajas que es útil para visualizar la distribución de una variable cuantitativa.
geom_boxplot()+
# 'theme_bw()' aplica un tema en blanco y negro para la visualización.
# Este tema proporciona un fondo claro y líneas oscuras, lo que resulta en un gráfico con alto contraste y fácil de leer.
theme_bw()
lab |> select(where(is.numeric), -codigo) |>  # Selecciona solo las variables numéricas, excluyendo 'codigo'
drop_na() |>  # Elimina filas con valores NA
descr() # 'descr' es la función que se aplica. Calcula estadísticas descriptivas para todas las variables numéricas.
# 'z_ph <- scale(lab$ph)' calcula el puntaje z para la columna 'ph' del dataframe 'lab'.
z_ph <- scale(lab$ph)
# 'scale()' es una función en R que estandariza los datos.
# Resta la media y divide por la desviación estándar, resultando en datos con una media de 0 y una desviación estándar de 1.
# Esto es útil para normalizar datos, especialmente en preparación para ciertos análisis estadísticos.
# 'mean(z_ph)' calcula la media de los puntajes z de 'ph'.
mean(z_ph)
# 'sd(z_ph)' calcula la desviación estándar de los puntajes z de 'ph'.
sd(z_ph)
# Transforma 'lab' creando una nueva columna 'clases_est' que clasifica 'est' en 8 intervalos
lab |>
mutate(clases_est = cut(est, breaks = 8)) |>
# Cuenta la frecuencia de cada clase en 'clases_est'
count(clases_est)
# Utiliza 'knitr::kable' para crear una tabla formateada de la tabla de proporciones de 'imperfecciones'
knitr::kable(
# Calcula la tabla de proporciones para la columna 'imperfecciones' en 'lab'
prop.table(table(lab$imperfecciones)),
# Redondea los números a 4 decimales
digits = 4
)
# Genera un histograma de la columna 'ph' del dataframe 'lab', pero no lo dibuja (plot = FALSE).
# El resultado se guarda en 'histo', que contiene, entre otros, los límites de los intervalos (breaks).
histo <- hist(lab$ph, plot = FALSE)
# Actualiza el dataframe 'lab' mediante 'mutate' para añadir una nueva columna 'clase'.
# 'cut' se utiliza para dividir la columna 'ph' en intervalos basados en los límites encontrados en 'histo$breaks'.
lab <- lab |>
mutate(clase = cut(ph, breaks = histo$breaks))
# Añade un nivel adicional "(6.4,6.45]" a los factores de la columna 'clase'.
# Esto es para incluir valores específicos que no estaban originalmente en los intervalos generados por 'hist' porque su suma es frecuencia es 0.
levels(lab$clase) <- c(levels(lab$clase), "(6.4,6.45]")
# Calcula la tabla de frecuencias para 'lab$clase' y la convierte en un dataframe.
tabla_frecuencias <- as.data.frame(table(lab$clase))
# Añade una columna para la frecuencia relativa (f) y los acumulados (N y F) redondeado a 0.
tabla_frecuencias <- tabla_frecuencias |>
mutate(
f = round(Freq / sum(Freq), 4), # Frecuencia relativa redondeada a cuatro decimales
N = cumsum(Freq),               # Frecuencia acumulada
F = round(cumsum(f), 4)         # Frecuencia relativa acumulada redondeada a cuatro decimales
)
# Usa 'flextable' para crear una tabla flexible a partir de 'tabla_frecuencias'.
flextable(tabla_frecuencias) |>
# Personaliza los encabezados de la tabla.
flextable::set_header_labels(
Var1 = "Clase",
Freq = "n",
f = "Frecuencia Relativa",
N = "Frecuencia Acumulada",
F = "Frecuencia Relativa Acumulada"
)
# Crea una tabla de contingencia absoluta entre las variables 'analista' y 'tipo' y la muestra en formato Markdown
kable(table(lab$analista, lab$tipo))
# Crea una tabla de contingencia relativa (frecuencias relativas) para las mismas variables y la muestra con dos decimales
kable(prop.table(table(lab$analista, lab$tipo)), digits = 2)
# Crea una tabla de contingencia usando la función 'ctable' del paquete 'summarytools'.
tabla_contingencia <- summarytools::ctable(lab$tipo, lab$analista)
# 'summarytools::ctable' es una función del paquete 'summarytools' que se utiliza para crear tablas de contingencia.
# 'lab$tipo' y 'lab$analista' son las dos variables del dataframe 'lab' que se están comparando.
# La tabla de contingencia resultante mostrará la frecuencia de cada combinación de 'tipo' y 'analista'.
# Selecciona la primera tabla de la lista 'tabla_contingencia', la convierte en un tibble y filtra por 'analista_13'.
tabla_contingencia[[1]] |>
# 'as_tibble()' convierte la tabla (que probablemente sea una matriz o dataframe) en un tibble, que es un tipo de dataframe moderno en R.
as_tibble() |>
# 'filter(analista == 'analista_13')' filtra las filas donde la columna 'analista' es igual a 'analista_13'.
filter(analista == 'analista_13')
# Selecciona la primera tabla de la lista 'tabla_contingencia', la convierte en un tibble y filtra por 'tipo == 'A''.
tabla_contingencia[[1]] |>
# 'as_tibble()' convierte la tabla en un tibble.
as_tibble() |>
# 'filter(tipo == 'A')' filtra las filas donde la columna 'tipo' es igual a 'A'.
filter(tipo == 'A')
# Genera histogramas para las variables 'ph' y 'est' sin mostrar los gráficos, para determinar los intervalos de clase
histo <- hist(lab$ph, plot = FALSE)
histo2 <- hist(lab$est, plot = FALSE, breaks = 4)
# Clasifica las variables 'ph' y 'est' en categorías basadas en los intervalos anteriores y añade estas categorías al dataframe
lab <- lab |>
mutate(clase_ph = cut(ph, breaks = histo$breaks)) |>
mutate(clase_est = cut(est, breaks = histo2$breaks))
# Ajusta manualmente los niveles de la variable 'clase_ph' para incluir un intervalo específico
levels(lab$clase_ph) <- c(levels(lab$clase_ph), "(6.4,6.45]")
# Crea una tabla de contingencia entre las categorías de 'ph' y 'est', añadiendo totales con addmargins(), y la muestra
tabla <- table(lab$clase_ph, lab$clase_est) |> addmargins()
tabla |> kable()
lab |> select(where(is.numeric), -codigo) |>  # Selecciona solo las variables numéricas, excluyendo 'codigo'
drop_na() |>  # Elimina filas con valores NA
cov() |>  # Calcula la matriz de covarianzas
round(2)  # Redondea los resultados a 2 decimales
lab |> select(where(is.numeric), -codigo) |>  # Selecciona solo las variables numéricas, excluyendo 'codigo'
drop_na() |>  # Elimina filas con valores NA
cor() |>  # Calcula la matriz de correlación
round(2)  # Redondea los resultados a 2 decimales
# 'lab |> select(where(is.numeric), -codigo)' selecciona las columnas numéricas del dataframe 'lab', excluyendo la columna 'codigo'.
lab |>
select(where(is.numeric), -codigo) |>
# 'drop_na()' elimina todas las filas que contienen valores NA (faltantes).
drop_na() |>
# 'cor()' calcula la matriz de correlación entre las columnas numéricas seleccionadas.
cor() |>
# 'round(2)' redondea los coeficientes de correlación a dos decimales.
round(2) |>
# 'corrplot()' visualiza la matriz de correlación.
corrplot(
method = "ellipse",  # 'method = "ellipse"' utiliza elipses para representar los coeficientes de correlación.
type = "lower",      # 'type = "lower"' muestra solo la mitad inferior de la matriz de correlación.
addCoef.col = "steelblue",  # 'addCoef.col = "steelblue"' establece el color de los coeficientes de correlación.
diag = FALSE         # 'diag = FALSE' omite la diagonal principal de la matriz, que siempre es 1.
)
# Gráficos de barras para frecuencias conjuntas
# Crea un gráfico de barras para las variables 'tipo' y 'analista' usando ggplot2
lab |> # Toma el dataframe 'lab'
ggplot(aes(x = tipo, fill = analista)) + # Inicializa ggplot2, asignando 'tipo' al eje x y coloreando por 'analista'
geom_bar() + # Añade un gráfico de barras, que por defecto cuenta la cantidad de cada 'tipo'
theme_bw() # Aplica un tema en blanco y negro para una visualización más clara y profesional
lab |> # Toma el dataframe 'lab'
ggplot(aes(x = tipo, fill = analista)) + # Inicializa ggplot2, asignando 'tipo' al eje x y coloreando por 'analista'
geom_bar(position = position_dodge()) + # Añade un gráfico de barras con barras separadas por 'analista' dentro de cada 'tipo'
theme_bw() # Aplica un tema en blanco y negro para una visualización más clara y profesional
# Crear un histograma de 'ph' con colores basados en 'tipo'
ggplot(lab, aes(x = ph, fill = tipo)) +
# Añadir la capa de histograma
geom_histogram(
bins = 15,
alpha = 0.7,  # Ajusta la transparencia para mejor visualización
position = 'identity'  # Superpone las barras
) +
# Definir los títulos de los ejes y el gráfico
labs(
title = "Histograma de pH por Tipo",
x = "pH",
y = "Frecuencia"
) +
# Aplicar un tema
theme_bw() +
# Añadir leyenda (automáticamente generada por ggplot)
guides(fill=guide_legend(title="Tipo"))
# Gráfico de dispersión
# Crea un gráfico de dispersión para las variables 'est' y 'ph'
lab |>
# 'ggplot()' inicia una gráfica utilizando el paquete ggplot2. 'aes()' define las estéticas del gráfico, asignando 'est' al eje x y 'mg' al eje y.
ggplot(aes(x = est, y = mg)) +
# 'geom_point()' añade capas de puntos al gráfico, lo que crea un gráfico de dispersión con puntos representando las combinaciones de 'est' y 'mg'.
geom_point()
# Gráfico de dispersión
# Crea un gráfico de dispersión para las variables 'est' y 'mg'
lab |>
# 'ggplot()' inicia una gráfica utilizando el paquete ggplot2. 'aes()' define las estéticas del gráfico, asignando 'est' al eje x y 'mg' al eje y.
ggplot(aes(x = est, y = mg)) +
# 'geom_point()' añade capas de puntos al gráfico, lo que crea un gráfico de dispersión con puntos representando las combinaciones de 'est' y 'mg'.
geom_point() +
# 'geom_smooth()' añade una línea de tendencia o ajuste al gráfico. Por defecto, realiza un ajuste de regresión lineal que muestra la tendencia general entre 'est' y 'mg'.
geom_smooth(method = lm) +
# 'labs()' permite personalizar las etiquetas del gráfico, como el título. Aquí se establece el título del gráfico.
labs(title = "Gráfico de dispersión con ajuste de regresión")
# Gráfico de dispersión
# Crea un gráfico de dispersión para las variables 'est' y 'ph'
lab |>
# 'ggplot()' inicia una gráfica utilizando el paquete ggplot2. 'aes()' define las estéticas del gráfico, asignando 'est' al eje x y 'mg' al eje y.  Además, la estética 'col' se usa para colorear los puntos según el valor de la variable 'tipo'.
ggplot(aes(x = est, y = mg, col = tipo)) +
# 'geom_point()' añade capas de puntos al gráfico, lo que crea un gráfico de dispersión con puntos representando las combinaciones de 'est' y 'mg'.
geom_point() +
# 'geom_smooth()' añade una línea de tendencia o ajuste al gráfico. Realiza un ajuste de regresión lineal que muestra la tendencia general entre 'est' y 'mg', para cada valor de la varaible tipo.
geom_smooth(method = lm) +
# 'labs()' permite personalizar las etiquetas del gráfico, como el título. Aquí se establece el título del gráfico.
labs(title = "Gráfico de dispersión con ajuste de regresión")
# Gráficos de cajas por grupos
lab |>
ggplot(aes(x = tipo, y = ph)) +  # Define las variables para el eje x ('tipo') y el eje y ('ph')
geom_boxplot() +  # Crea un gráfico de cajas
theme_bw() +  # Utiliza un tema en blanco y negro para el gráfico
labs(title = "pH por tipo de queso")  # Añade un título al gráfico
# Gráficos de cajas por grupos eje y color
lab |>
ggplot(aes(x = analista, y = ph)) +  # Establece 'analista' en el eje x y 'ph' en el eje y
geom_boxplot() +  # Genera el gráfico de cajas
geom_jitter(aes(col = tipo), alpha = 0.2) +  # Añade puntos individuales para mostrar la distribución, con color por 'tipo'
theme_bw() +  # Aplica un tema en blanco y negro
labs(title = "pH por analista")  # Asigna un título al gráfico
# 'ggpairs()' es una función del paquete GGally que crea pares de gráficos para cada combinación de variables.
ggpairs(
# 'lab |> select(ph, est, mg, sal, tipo)' selecciona las columnas específicas 'ph', 'est', 'mg', 'sal' y 'tipo' del dataframe 'lab'.
lab |> select(ph, est, mg, sal, tipo),
# 'aes(col = tipo)' define las estéticas para el gráfico, en este caso, asignando diferentes colores a cada valor de 'tipo'.
aes(col = tipo)
)
lab |>  select(where(is.numeric), -codigo) |>   # Selecciona todas las columnas numéricas menos el código
drop_na() |>  # Elimina las filas con valores NA
summarise(across(everything(), mean))  # Calcula la media para las columnas seleccionadas
# Resumen numérico de una variable continua para cada categoría de otra discreta
# 'with(lab, stby(mg, tipo, descr))' aplica una función a un subconjunto de datos dentro del dataframe 'lab'.
with(
# 'lab' es el dataframe que contiene los datos.
lab,
# 'stby()' es una función que aplica otra función ('descr' en este caso) a subconjuntos de datos.
# Aquí se aplica 'descr' a la variable 'mg', agrupada por los valores de 'tipo'.
stby(
# 'mg' es la variable a la que se le aplicará la función 'descr'.
mg,
# 'tipo' es la variable de agrupación. 'descr' se aplicará por separado a los grupos definidos por 'tipo'.
tipo,
# 'descr' es la función que se aplica. Calcula estadísticas descriptivas para 'mg' dentro de cada grupo de 'tipo'.
descr
)
)
# Recta de refresión de la variable 'est' en función de 'mg'
lab |>
slice(1:15) |>  # Selecciona los primeros 15 registros
select(mg, est) |>  # Selecciona las columnas 'mg' y 'est'
ggplot(aes(x=mg, y = est)) +  # Define las variables para el gráfico
geom_point() +  # Añade puntos al gráfico
theme_bw() +  # Aplica un tema en blanco y negro
geom_smooth(method = lm, se = FALSE)  # Añade una línea de regresión lineal sin intervalo de confianza
# Creación y resumen de un modelo lineal para 'est' en función de 'mg'
mod <- lab |>
slice(1:15) |>  # Selecciona los primeros 15 registros
select(mg, est) |>  # Selecciona las variables 'mg' y 'est'
with(lm(est ~ mg))  # Crea un modelo lineal de 'est' en función de 'mg'
# Muestra un resumen del modelo lineal
# Esto incluye estadísticas como el R-cuadrado, los coeficientes del modelo, sus errores estándar, valores t y p-valores.
# Es útil para evaluar la calidad del ajuste y la significancia de las variables.
summary(mod)
# Recta de refresión de la variable 'est' en función de 'mg' filtrando por tipo 'C'
lab |>
# 'filter(tipo == "C")' filtra el dataframe para incluir solo las filas donde la columna 'tipo' es igual a "C".
filter(tipo == "C") |>
# 'ggplot(aes(x = mg, y = est))' inicia la creación de un gráfico ggplot2, definiendo 'mg' como la variable del eje x y 'est' como la del eje y.
ggplot(aes(x = mg, y = est)) +
# 'geom_point()' añade una capa de puntos al gráfico, mostrando la relación entre 'mg' y 'est' para las observaciones donde 'tipo' es "C".
geom_point() +
# 'geom_smooth(method = "lm")' añade una línea de ajuste lineal al gráfico. 'method = "lm"' indica que se usa un modelo lineal para el ajuste.
geom_smooth(method = "lm")
# 'modelo <- lm(est ~ mg, data = lab, subset = tipo == "C")' crea un modelo lineal.
modelo <- lm(
# 'est ~ mg' define la fórmula del modelo, donde 'est' es la variable dependiente y 'mg' la variable independiente.
est ~ mg,
# 'data = lab' especifica que los datos para el modelo provienen del dataframe 'lab'.
data = lab,
# 'subset = tipo == "C"' restringe el análisis a las filas del dataframe donde 'tipo' es igual a "C".
subset = tipo == "C"
)
# 'summary(modelo)' proporciona un resumen del modelo lineal ajustado.
# Esto incluye estadísticas como el R-cuadrado, los coeficientes del modelo, sus errores estándar, valores t y p-valores.
# Es útil para evaluar la calidad del ajuste y la significancia de las variables.
summary(modelo)
knitr::opts_chunk$set(echo = TRUE,
eval = TRUE,
warning = FALSE,
message = FALSE,
error = TRUE)
library(tidyverse)
datos2 <- read.csv("Sleep_health_and_lifestyle_dataset.csv")
datos2|>count(Gender)
datos2 |>
ggplot(aes(x = Gender)) +
geom_bar(fill = "#9dcb43") +
theme_bw() +
labs(title = "Genero",
x = "Sexo",
y = "Frecuencia absoluta")
